# 分治算法

## Introduction

分治算法的两个步骤：

1. 分（划分阶段）: 递归地将原问题分解为两个或者多个子问题，直到到达最小子问题时终止。

2. 治（合并阶段）: 从已知解的最小子问题开始，从底至顶将子问题的解进行合并，从而构建出原问题的解。

判断分治问题的方法：

1. 问题可以分解：原问题可以分解成规模更小、类似的子问题，以及能够以相同方式递归地进行划分。

2. 子问题是独立的：子问题之间没有重叠，互不依赖，可以独立解决。

3. 子问题的解可以合并：原问题的解通过合并子问题的解得来

> 分治算法是一种“润物细无声”的算法，隐藏在各种数据结构和算法中。  
> 越简单的算法，它的应用就越广泛。

## Examples

1. **分治搜索策略**: 基于分治的二分查找  
    > 问题：给定一个长度为$n$的有序数组$nums$，其中所有的元素唯一，请找到元素$target$。  

    题解  
    将搜索区间`[i, j]`对应的子问题标记为`f[i,j]`。  
    原问题以`f[0, n-1]`为起点。  
    1. 计算搜索区间[i, j]的中点m, 根据它排除一半的搜索区间.
        - 如果nums[m] > target, 说明target不可能在右边的区间中，搜索[0, m-1]区间。
        - 如果nums[m] < target, 说明target不可能在左边的区间，则搜索[m+1, j]区间。
        - 如果nums[m] == target, 则直接返回m。
    2. 递归求解规模减小一半的子问题，可能是f[i, m - 1]也可能是f[m+1, j]。   
    3. 循环 `1.` 和 `2.`步，直到找到target或者区间为空时返回。

2. **构建二叉树**  
    > 问题：给定一棵二叉树的前序遍历 preorder 和中序遍历 inorder ，请从中构建二叉树，返回二叉树的根节点。假设二叉树中没有值重复的节点。

    题目解析
    - 判断是否可以通过分治解决该问题
        1. 问题可分解  
        原问题划分为两个子问题：构建左子树、构建右子树，并加上一步操作：初始化根节点。  
        对于每棵子树（子问题），我们仍然可以复用以上划分方法, 将其划分为更小的子树（子问题）。   
        直至达到最小子问题（空子树）时终止。
        2. 子问题是独立的：左子树和右子树是相互独立的，它们之间没有交集。在构建左子树时，我们只需关注中序遍历和前序遍历中与左子树对应的部分。右子树同理。
        3. 子问题的解可以合并：一旦得到了左子树和右子树（子问题的解），我们就可以将它们链接到根节点上，得到原问题的解。
    - 本题中如何划分子树  
        1. 前序遍历的首元素是根节点root。
        2. 查找root在中序遍历中的索引。
        3. root索引左边的构成root的左子树，root索引右边的元素构成右子树。
    - 基于变量描述子树区间  
    i表示当前子树的根节点在中序遍历中的索引;  

        ||根节点在前序遍历中的索引|子树在中序遍历中的区间([start, end])|
        |---|:---:|:---:|
        |根节点|m           |[l, r]     |
        |左子树|m+1         |[l, i-1]   |  
        |右子树|m+(i-l)+1   |[i+1, r]   |
    