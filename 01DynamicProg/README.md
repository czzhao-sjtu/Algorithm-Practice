# 动态规划
动态规划是一个重要的算法范式，它将一个问题分解成一系列的更小的子问题，并通过存储子问题的解来避免重复计算，从而提升效率。

与回溯算法一样，动态规划也使用“状态”概念来表示问题求解的特定阶段，每个状态都对应于
    
    1. 一个子问题
    2. 子问题所对应的局部最优解

例如，爬楼梯问题的状态定义为当前所在楼梯阶数i。

常用术语

- 状态转移方程
- dp表
- 初始状态

在动态规划问题中，当前状态往往仅与前面有限个状态有关，这时我们可以只保留必要的状态，通过“降维”来节省内存空间。这种空间优化技巧被称为“**滚动变量**”或“**滚动数组**”。

## 1. 动态规划问题特征

- 最优子结构: 原问题的最优解是由子问题的最优解构造得到。

    最优子结构的解释方式比较灵活，在不同的问题中有不同的含义。

- 无后效性: 给定一个确定的状态，其未来发展只与当前状态有关，与过去所经历的所有状态无关。 

    无后效性是动态规划问题的一个重要特征，它使得我们可以从前往后递推，而不必考虑状态的历史变化过程。

    当在一种状态定义下，无后效性不成立时，我们可以通过引入更多的状态来保证无后效性。

    但是如果在当前状态依赖过去所有的状态，那么我们就无法通过动态规划来解决问题。

    对于许多复杂组合优化问题，如旅行商问题，不满足无后效性。我们通常采用启发式搜索、遗产算法、强化学习等，从而在有限的时间内找到可用的局部最优解。

## 2. 动态规划解题思路

- 如何判断一个问题是否是动态规划问题？

    规范来讲，如果一个问题具有重叠子问题、最优子结构、无后效性，则可以通过动态规划来求解。

   一般来讲，有些问题不容易看出来是否满足上面的条件，从实践角度，我们可以通过它是否满足决策树模型来判断其是否可以通过动态规划来解决。 

- 求解动态规划问题该从何处入手，完整步骤是什么？

    1. 描述决策

    2. 定义状态

    3. 建立dp表

    4. 推导状态转移方程

    5. 确定边界条件 和 状态转移顺序

    示例问题：给定一个 $n\times m$ 的二维网格 `grid` ，网格中的每个单元格包含一个非负整数，表示该单元格的代价。机器人以左上角单元格为起始点，每次只能向下或者向右移动一步，直至到达右下角单元格。请返回从左上角到右下角的最小路径和。

    1. 描述决策

        每轮决策从当前格子向下或者向右走一步。

    2. 定义状态

        状态包含两个维度，即当前所在行和列`[i, j]`。

        **状态的维度**

        其实是问题的维度，而不是决策变量的维度。在本题中，决策变量是机器人的移动方向，而问题的维度是机器人的位置。

    3. 建立dp表

        状态`[i, j]`对应的子问题为：从起点`[0, 0]`到达`[i, j]`的最小路径和, 记作`dp[i, j]`。

    4. 推导状态转移方程

        机器人只能向下或者向右移动，因此到达`[i, j]`的最小路径和只能从`[i-1, j]`或者`[i, j-1]`转移过来。

        状态转移方程为：`dp[i, j] = min(dp[i-1, j], dp[i, j-1]) + grid[i, j]`。

    5. 确定边界条件 和 状态转移顺序
        
        在本题中，处在首行的状态只能从其左边的状态得来，处在首列的状态只能从其上边的状态得来，因此首行 `i=0`和首列`j=0`是边界条件。

        由于每个格子是由其左方格子和上方格子转移而来，因此我们使用循环来遍历矩阵，外循环遍历各行，内循环遍历各列。

## 3. 动态规划问题实例

- 0-1背包问题

    给定 $n$ 个物品，第$i$个物品的重量为$wgt[i-1]$、价值为$val[i-1]$，和一个容量为$cap$的背包。每个物品只能选择一次，问在限定背包容量下能放入物品的最大价值。

    1. 每轮的决策

        对于每个物品，可以选择放入背包或者不放入背包。

        不放入背包，则背包容量不变。

        放入背包，则背包容量减少。

        每轮的决策可能性给出了状态转移方程的线索。不同的决策不一定是最终解的一部分，但是最终解一定来自于某个决策。

    2. 定义状态：当前物品编号$i$和容量$c$。

        这里状态包含了两个维度：物品编号和背包容量。

        状态是对问题的描述，而不是具体的每个决策变量。

    3. 建立dp表

        状态$[i, c]$对应的子问题是：前$i$个物品放入容量为$c$的背包中的最大价值，记作$dp[i, c]$。问题的最终答案为$dp[n, cap]$, 则dp表的大小为$(n+1)\times(cap+1)$。

    4. 推导状态转移方程

        对于第$i$个物品，有两种选择：放入背包或者不放入背包。

        如果不放入背包，则$dp[i, c] = dp[i-1, c]$。

        如果放入背包，则$dp[i, c] = dp[i-1, c-wgt[i-1]] + val[i-1]$。

        状态转移方程为：$dp[i, c] = max(dp[i-1, c], dp[i-1, c-wgt[i-1]] + val[i-1])$。

    5. 确定边界条件 和 状态转移顺序

        边界条件为：$dp[0, c] = 0$和$dp[i, 0] = 0$。

        状态转移顺序为：外循环遍历物品，内循环遍历背包容量。

- 完全背包问题

    给定n个物品，第$i$个物品的重量为$wgt[i-1]$、价值为$val[i-1]$，和一个容量为$cap$的背包。每个物品可以重复选取，问在限定背包容量下能放入物品的最大价值。

    解题：可以看出，该问题可以通过回溯算法来解决，找到所有的组合，然后选择价值最大的组合。在使用回溯算法求解的过程中，其决策过程形成了一个决策树，因此可以尝试通过动态规划来解决。

    1. 每轮的决策

        有n种物品，可以选择其中一个放入背包，也可以一个都不放入背包，因此共有n+1种决策。

    2. 定义状态：当前的背包容量$c$。

    3. 建立dp表

        状态$[c]$对应的子问题是：容量为$c$的背包中的最大价值，记作$dp[c]$。

        因此本文中需要建立一个大小为$cap+1$的dp表。 

    4. 状态转移方程

        如果所有物品的重量都大于背包的重量，则$dp[c] = dp[c-1] = dp[c-2] = \cdots = 0$。

        如果有重量小于背包容量的物品，则$dp[c]=max(\{dp[c - wgt[i]] + val[i]\}_{i\in\{wgt[i-1]<=c\}})$

    5. 确定边界条件 和 状态转移顺序

        边界条件为：$dp[0] = dp[1] = \cdots = dp[j] = 0, \text{subject to }j = min(wgt) -1 $。

        状态转移顺序为：从最小的物品重量开始开始，逐渐增大背包容量。

- 零钱兑换问题

    给定n种硬币，第i种硬币的面值为coins[i-1]，目标金额为amt，每种硬币可以重复选取，问能够凑出目标金额的最少硬币数量。如果无法凑出目标金额，则返回-1。

    1. 每轮的选择

        在每轮共有n种选择，即选择其中一枚硬币。

    2. 定义状态：当前的金额c。

    3. 建立dp表

        dp[c]表示凑出金额c的最少硬币数量。

    4. 状态转移方程

        $c >= 1$

        $dp[c] = min(\{dp[c - coins[i]]\})_{i\in\{coins[i-1]<=c\}} + 1$

        在每一轮选择一枚硬币，然后减去硬币的面值，得到剩余的金额，然后查找剩余金额对应的最少硬币数量，最后加上当前选择的硬币数量1。

    5. 确定边界条件 和 状态转移顺序

        边界条件：$dp[0] = 0$。

        状态转移顺序：从1开始逐渐增大金额。

- 零钱兑换问题 II

    给定n种硬币，第i种硬币的面值为coins[i-1]，目标金额为amt，每种硬币可以重复选取，问有多少种凑出目标金额的方法。

    1. 每轮的选择

        对于每种硬币，可以选择放入背包或者不放入背包。

    2. 定义状态：[i,j] i表示从前i种硬币中选择，j表示需要凑出的金额。

    3. 建立dp表

        dp[i, j]从i种硬币中凑出金额j的组合数量。

        dp表的大小为$(n + 1) \times (j+1)$

    4. 状态转移方程

        $dp[i, j] = dp[i - 1, j] + dp[i, j - coins[i - 1]]$

        其中dp[i - 1, j]表示一个i都不使用凑到金额j的组合数量，dp[i, j - coins[i - 1]]表示至少使用第i种硬币一个凑到金额j的数量产生的组合数量。 

    5. 确定边界条件 和 状态转移顺序

        边界条件：
            
            行为0:$dp[0, j] = 0$。
            列为0:$dp[i, 0] = 1$

        状态转移顺序：外层循环从1开始遍历硬币索引i, 内层循环从1开始遍历金额j。

    - 零钱兑换问题I 和 II的区别

        零钱兑换问题I是求最少硬币数量，使用min操作组合子问题的结果, 组合前后有重复不会一项最终的结果；
        
        零钱兑换问题II是求组合数量，使用+操作组合子问题结果，如果组合有重复则会导致算出来的结果比真实值多。

- 编辑距离问题

    输入两个字符串s和t，返回将s转换为t所需的最少编辑步数。

    你可以在一个字符串中进行三种编辑操作：插入一个字符、删除一个字符、将字符替换为任意一个字符。

    题解：

    1. 每轮的决策

        每一轮的决策中对字符串s进行一次编辑操作。
        
        首先考虑尾部字符s[n - 1] 和 t[m - 1], 如果二者相等，则不进行编辑操作。

        如果二者不同，则可以进行尾部插入、删除、或者替换的操作。

    2. 定义状态: [i, j] 对应的子问题是 将s[0:i] 转换成 t[0:j]所需的最小编辑步数

    3. 建立dp表: dp[i, j] 表示 将s[0:i] 转换成 t[0:j]所需的最小编辑步数

        dp表大小$(n+1) \times (m+1)$

    4. 构建状态转移方程: 

        - 如果s[i-1] == t[j-1]

            则dp[i, j] = dp[i-1, j-1]

        - 如果s[i-1] != t[j-1]

            - 如果使用插入操作将t[j-1]插入到s[i-1]的后面, 则dp[i, j] = dp[i, j-1] + 1

            - 如果使用删除将s[i-1]删除，则dp[i, j] = dp[i - 1, j] + 1

            - 如果使用替换操作将s[i-1]替换成t[j-1], 则dp[i, j] = dp[i-1, j-1] + 1

            具体使用哪种操作取决于相应的子问题哪个步数最小，整理下得到

            dp[i, j] = min(dp[i, j-1], dp[i-1, j], dp[i-1, j-1]) + 1

    5. 初始状态 和 状态转移顺序

        初始状态

            首列: dp[i, 0] = i, 0<= i <=n
            首行: dp[0, j] = j, 0<= j <=m

        状态转移顺序

            外层循环索引行，内层循环索引列

    