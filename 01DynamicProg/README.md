# 动态规划
动态规划是一个重要的算法范式，它将一个问题分解成一系列的更小的子问题，并通过存储子问题的解来避免重复计算，从而提升效率。

与回溯算法一样，动态规划也使用“状态”概念来表示问题求解的特定阶段，每个状态都对应于
    
    1. 一个子问题
    2. 子问题所对应的局部最优解

例如，爬楼梯问题的状态定义为当前所在楼梯阶数i。

常用术语

- 状态转移方程
- dp表
- 初始状态

在动态规划问题中，当前状态往往仅与前面有限个状态有关，这时我们可以只保留必要的状态，通过“降维”来节省内存空间。这种空间优化技巧被称为“**滚动变量**”或“**滚动数组**”。

## 1. 动态规划问题特征

- 最优子结构: 原问题的最优解是由子问题的最优解构造得到。

    最优子结构的解释方式比较灵活，在不同的问题中有不同的含义。

- 无后效性: 给定一个确定的状态，其未来发展只与当前状态有关，与过去所经历的所有状态无关。 

    无后效性是动态规划问题的一个重要特征，它使得我们可以从前往后递推，而不必考虑状态的历史变化过程。

    当在一种状态定义下，无后效性不成立时，我们可以通过引入更多的状态来保证无后效性。

    但是如果在当前状态依赖过去所有的状态，那么我们就无法通过动态规划来解决问题。

    对于许多复杂组合优化问题，如旅行商问题，不满足无后效性。我们通常采用启发式搜索、遗产算法、强化学习等，从而在有限的时间内找到可用的局部最优解。

## 2. 动态规划解题思路

- 如何判断一个问题是否是动态规划问题？

    规范来讲，如果一个问题具有重叠子问题、最优子结构、无后效性，则可以通过动态规划来求解。

   一般来讲，有些问题不容易看出来是否满足上面的条件，从实践角度，我们可以通过它是否满足决策树模型来判断其是否可以通过动态规划来解决。 

- 求解动态规划问题该从何处入手，完整步骤是什么？

    1. 描述决策

    2. 定义状态

    3. 建立dp表

    4. 推导状态转移方程

    5. 确定边界条件 和 状态转移顺序

    示例问题：给定一个 $n\times m$ 的二维网格 `grid` ，网格中的每个单元格包含一个非负整数，表示该单元格的代价。机器人以左上角单元格为起始点，每次只能向下或者向右移动一步，直至到达右下角单元格。请返回从左上角到右下角的最小路径和。

    1. 描述决策

        每轮决策从当前格子向下或者向右走一步。

    2. 定义状态

        状态包含两个维度，即当前所在行和列`[i, j]`。

        **状态的维度**

        其实是问题的维度，而不是决策变量的维度。在本题中，决策变量是机器人的移动方向，而问题的维度是机器人的位置。

    3. 建立dp表

        状态`[i, j]`对应的子问题为：从起点`[0, 0]`到达`[i, j]`的最小路径和, 记作`dp[i, j]`。

    4. 推导状态转移方程

        机器人只能向下或者向右移动，因此到达`[i, j]`的最小路径和只能从`[i-1, j]`或者`[i, j-1]`转移过来。

        状态转移方程为：`dp[i, j] = min(dp[i-1, j], dp[i, j-1]) + grid[i, j]`。

    5. 确定边界条件 和 状态转移顺序
        
        在本题中，处在首行的状态只能从其左边的状态得来，处在首列的状态只能从其上边的状态得来，因此首行 `i=0`和首列`j=0`是边界条件。

        由于每个格子是由其左方格子和上方格子转移而来，因此我们使用循环来遍历矩阵，外循环遍历各行，内循环遍历各列。

## 3. 动态规划问题实例

- 0-1背包问题

    给定 $n$ 个物品，第$i$个物品的重量为$wgt[i-1]$、价值为$val[i-1]$，和一个容量为$cap$的背包。每个物品只能选择一次，问在限定背包容量下能放入物品的最大价值。

    1. 每轮的决策

        对于每个物品，可以选择放入背包或者不放入背包。

        不放入背包，则背包容量不变。

        放入背包，则背包容量减少。

        每轮的决策可能性给出了状态转移方程的线索。不同的决策不一定是最终解的一部分，但是最终解一定来自于某个决策。

    2. 定义状态：当前物品编号$i$和容量$c$。

        这里状态包含了两个维度：物品编号和背包容量。

        状态是对问题的描述，而不是具体的每个决策变量。

    3. 建立dp表

        状态$[i, c]$对应的子问题是：前$i$个物品放入容量为$c$的背包中的最大价值，记作$dp[i, c]$。问题的最终答案为$dp[n, cap]$, 则dp表的大小为$(n+1)\times(cap+1)$。

    4. 推导状态转移方程

        对于第$i$个物品，有两种选择：放入背包或者不放入背包。

        如果不放入背包，则$dp[i, c] = dp[i-1, c]$。

        如果放入背包，则$dp[i, c] = dp[i-1, c-wgt[i-1]] + val[i-1]$。

        状态转移方程为：$dp[i, c] = max(dp[i-1, c], dp[i-1, c-wgt[i-1]] + val[i-1])$。

    5. 确定边界条件 和 状态转移顺序

        边界条件为：$dp[0, c] = 0$和$dp[i, 0] = 0$。

        状态转移顺序为：外循环遍历物品，内循环遍历背包容量。

- 完全背包问题

    给定n个物品，第$i$个物品的重量为$wgt[i-1]$、价值为$val[i-1]$，和一个容量为$cap$的背包。每个物品可以重复选取，问在限定背包容量下能放入物品的最大价值。

    解题：可以看出，该问题可以通过回溯算法来解决，找到所有的组合，然后选择价值最大的组合。在使用回溯算法求解的过程中，其决策过程形成了一个决策树，因此可以尝试通过动态规划来解决。

    1. 每轮的决策

        有n种物品，可以选择其中一个放入背包，也可以一个都不放入背包，因此共有n+1种决策。

    2. 定义状态：当前的背包容量$c$。

    3. 建立dp表

        状态$[c]$对应的子问题是：容量为$c$的背包中的最大价值，记作$dp[c]$。

        因此本文中需要建立一个大小为$cap+1$的dp表。 

    4. 状态转移方程

        如果所有物品的重量都大于背包的重量，则$dp[c] = dp[c-1] = dp[c-2] = \cdots = 0$。

        如果有重量小于背包容量的物品，则$dp[c]=max(\{dp[c - wgt[i]] + val[i]\}_{i\in\{wgt[i-1]<=c\}})$

    5. 确定边界条件 和 状态转移顺序

        边界条件为：$dp[0] = dp[1] = \cdots = dp[j] = 0, \text{subject to }j = min(wgt) -1 $。

        状态转移顺序为：从最小的物品重量开始开始，逐渐增大背包容量。